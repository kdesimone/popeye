#!/usr/bin/python

""" Classes and functions for fitting population encoding models """

from __future__ import division, print_function, absolute_import

import warnings
warnings.simplefilter("ignore")

import numpy as np
from scipy.optimize import brute, fmin_powell
from scipy.special import gamma
from scipy.stats import linregress

import popeye.estimation as pest
import popeye.utilities as utils
from popeye.base import PopulationModel, PopulationFit
from popeye.spinach import MakeFastPrediction

def double_gamma_hrf(delay):
    """
    The double-gamma hemodynamic reponse function (HRF) used to convolve with
    the stimulus time-series.
    
    The user specifies only the delay of the peak and under-shoot The delay
    shifts the peak and under-shoot by a variable number of seconds.  The other
    parameters are hard-coded.  The HRF delay is modeled for each voxel
    independently.  The double-gamme HRF andhard-coded values are based on
    previous work (Glover, 1999).
    
    
    Parameters
    ----------
    delay : int
        The delay of the HRF peak and under-shoot.
        
        
    Returns
    -------
    hrf : ndarray
        The hemodynamic response function to convolve with the stimulus
        time-series.
    
    
    Reference
    ----------
    Glover, G.H. (1999) Deconvolution of impulse response in event-related BOLD.
    fMRI. NeuroImage 9: 416 429.
    
    """
    
    # add delay to the peak and undershoot params (alpha 1 and 2)
    alpha_1 = 5.0+delay
    beta_1 = 1.0
    c = 0.2
    alpha_2 = 15.0+delay
    beta_2 = 1.0
    
    t = np.arange(0,33)
    scale = 1
    hrf = scale*( ( ( t ** (alpha_1 - 1 ) * beta_1 ** alpha_1 *
                      np.exp( -beta_1 * t )) /gamma( alpha_1 )) - c *
        ( ( t ** (alpha_2 - 1 ) * beta_2 ** alpha_2 * np.exp( -beta_2 * t ))
          /gamma( alpha_2 ) ) )
            
    return hrf

def compute_model_ts(x, y, sigma, hrf_delay, deg_x, deg_y,
                    stim_arr, norm_func=utils.zscore):
    
    # otherwise generate a prediction
    ts_stim = MakeFastPrediction(deg_x,
                                 deg_y,
                                 stim_arr,
                                 x,
                                 y,
                                 sigma)
    
    # compute the hrf
    hrf = double_gamma_hrf(hrf_delay)
    
    # convolve and trim
    model_ts = np.convolve(ts_stim, hrf)
    model_ts = model_ts[0:stim_arr.shape[-1]]
    
    # normalized it
    model_ts = norm_func(model_ts)
    
    return model_ts


def error_function(parameters, response_ts, deg_x, deg_y, stim_arr):
    """
    The objective function that yields a minimizeable error between the
    predicted and actual BOLD time-series.
    
    The objective function takes candidate pRF estimates `parameters`,
    including a parameter for the screen location (x,y) and dispersion (sigma)
    of the 2D Gaussian as well as the HRF delay (tau).  The objective function
    also takes the ancillary parameters `deg_x` and `deg_y`, visual coordinate
    arrays, as well as the digitized stimulus array `stim_arr`.  The predicted
    time-series is generated by multiplying the pRF by the stimulus array and
    convolving the result with the double-gamma HRF.  The predicted time-series
    is mean centered and variance normalized.  The residual sum of squared
    errors is computed between the predicted and actual time-series and
    returned.
    
    This function makes use of the Cython optimising static compiler.
    MakeFastPrediction is written in Cython and computes the pre HRF convolved
    model time-series.
    
    Parameters
    ----------
    parameters : ndarray, tuple, list
        A quadruplet model parameters including the pRF estimate (x,y,sigma)
        and the HRF delay (tau).
        
    response_ts : ndarray
        A vector of the actual BOLD time-series extacted from a single voxel
        coordinate.
        
    deg_x : ndarray
        An array representing the horizontal extent of the visual display in
        terms of degrees of visual angle.
        
    deg_y : ndarray
        An array representing the vertical extent of the visual display in
        terms of degrees of visual angle.  stim_arr : ndarray Array_like means
        all those objects -- lists, nested lists, etc. -- that can be converted
        to an array.
    
    stim_arr: ndarray
        The binarized array representing the visual stimulus.
        
    Returns
    -------
    error : float
        The residual sum of squared errors computed between the predicted and
        actual time-series.    
    """
    
    # unpack the tuple
    x, y, sigma, hrf_delay = parameters[:]
    
    # if the x or y are off the screen, abort with an inf
    if np.abs(x) > np.floor(np.max(deg_x))-1:
        return np.inf
    if np.abs(y) > np.floor(np.max(deg_y))-1:
        return np.inf
        
    # if the sigma is larger than the screen width, abort with an inf
    if np.abs(sigma) > np.floor(np.max(deg_y))-1:
        return np.inf
        
    # if the sigma is <= 0, abort with an inf
    if sigma <= 0:
        return np.inf
        
    # if the HRF delay parameter is greater than 4 seconds, abort with an inf
    if np.abs(hrf_delay) > 4:
        return np.inf
        
    # otherwise generate a prediction
    model_ts = compute_model_ts(x, y, sigma, hrf_delay, deg_x, deg_y, stim_arr)
    
    # compute the RSS
    error = np.sum((model_ts-response_ts)**2)
    
    # catch NaN
    if np.isnan(np.sum(error)):
        return np.inf
        
    return error

def adaptive_brute_force_grid_search(bounds,epsilon,rounds,response_ts,deg_x,deg_y,
                                     stim_arr):
    """ 
    An adaptive brute force grid-search to generate a ball-park pRF estimate for
    fine tuning via a gradient descent error minimization.
    
    
    The adaptive brute-force grid-search sparsely samples the parameter space
    and uses a down-sampled version of the stimulus and cooridnate matrices.
    This is intended to yield an initial, ball-park solution that is then fed
    into the more finely-tuned fmin_powell in the compute_prf_estimate method
    below. 
    
    Parameters
    ----------
    bounds : tuple
        A tuple of paired tuples for the upper and lower bounds of the model
        parameters  e.g. ((-10,10),(-10,10),((0.25,5.25),(-4,4))
    epsilon : int
        The step-size for reducing the grid-search bounds on each iteration
        through the adaptive brute-force search. 
    rounds : int
        The number of iterations through the adaptive brute-force search
    response_ts : ndarray
        A vector of the actual BOLD time-series extacted from a single voxel
        coordinate.
    deg_x : ndarray
        An array representing the horizontal extent of the visual display in
        terms of degrees of visual angle.
    deg_y : ndarray
        An array representing the vertical extent of the visual display in
        terms of degrees of visual angle.
    stim_arr : ndarray
        Array_like means all those objects -- lists, nested lists, etc. --
        that can be converted to an array.
        
    Returns
    -------
    error : float
        The residual sum of squared errors computed between the predicted and
        actual time-series. 
        
    """
    
    # set initial pass to 1
    pass_num = 1
    
    # make as many passes as the user specifies in rounds
    while pass_num <= rounds:
        
        # get a fit estimate by sparsely sampling the 4-parameter space
        phat = brute(error_function,
                 args=(response_ts, deg_x, deg_y, stim_arr),
                 ranges=bounds,
                 Ns=5,
                 finish=fmin_powell)
                 
        # recompute the grid-search bounds by halving the sampling space
        epsilon /= 2.0
        bounds = ((phat[0]-epsilon,phat[0]+epsilon),
                  (phat[1]-epsilon,phat[1]+epsilon),
                  (phat[2]-epsilon,phat[2]+epsilon),
                  (phat[3]-epsilon,phat[3]+epsilon))
                  
        # iterate the pass variable
        pass_num += 1
        
    x, y, sigma, hrf_delay = phat[0], phat[1], phat[2], phat[3]
    
    return x, y, sigma, hrf_delay

def gradient_descent_search(x, y, sigma, hrf_delay,
                            error_function, response_ts, 
                            deg_x, deg_y, stim_arr):
                            
    [x, y, sigma, hrf_delay], err,  _, _, _, warnflag =\
        fmin_powell(error_function,(x, y, sigma, hrf_delay),
                    args=(response_ts,deg_x,deg_y,stim_arr),
                    full_output=True,
                    disp=False)

    return x, y, sigma, hrf_delay, err

class GaussianModel(PopulationModel):
    
    """
    Gaussian population receptive field model.
    """
    
    def __init__(self, stimulus):
        
        # this is a weird notation
        PopulationModel.__init__(self, stimulus)
        
    def fit(self, data, bounds, error_function, norm_func=utils.zscore):
        """ Fit method of the DTI model class
        
        Parameters
        ----------
        data : array
            The measured signal from one voxel.
            
        mask : array
            A boolean array used to mark the coordinates in the data that
            should be analyzed that has the shape data.shape[-1]
        """
        
        self.norm_func = norm_func
        normed_data = self.norm_func(data)
        
        return GaussianFit(self, normed_data, bounds, error_function)
        
class GaussianFit(object):
    
    """
    Gaussian population receptive field model fitting
    """
    
    def __init__(self, model, data, bounds, error_function):
        
        self.model = model
        self.data = data
        self.bounds = bounds
        self.error_function = error_function
        
        return None
    
    def lowres_model_ts(self, x, y, sigma, hrf_delay):
        
        
        return compute_model_ts(x, y, sigma, hrf_delay,
                                self.model.stimulus.deg_x_coarse,
                                self.model.stimulus.deg_y_coarse,
                                self.model.stimulus.stim_arr_coarse)
    
    def hires_model_ts(self, x, y, sigma, hrf_delay):
        
        return compute_model_ts(x, y, sigma, hrf_delay,
                                self.model.stimulus.deg_x,
                                self.model.stimulus.deg_y,
                                self.model.stimulus.stim_arr)
    
    def grid_search(self):
        
        return adaptive_brute_force_grid_search(self.bounds, 1, 3, self.data,
                                                self.model.stimulus.deg_x_coarse,
                                                self.model.stimulus.deg_y_coarse,
                                                self.model.stimulus.stim_arr_coarse)
    
    def gradient_descent(self, x, y, sigma, hrf_delay):
        
        return gradient_descent_search(x, y, sigma, hrf_delay,
                                       self.error_function,
                                       self.data, 
                                       self.model.stimulus.deg_x,
                                       self.model.stimulus.deg_y,
                                       self.model.stimulus.stim_arr)
    
    def compute_fit_stats(self, model_ts):
        
        return linregress(self.data, model_ts)
    
    def rss(self, model_ts):
        
        return np.sum((self.data - model_ts)**2)
    